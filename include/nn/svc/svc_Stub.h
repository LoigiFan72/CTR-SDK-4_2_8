/*---------------------------------------------------------------------------*
  Project:  Horizon
  File:     svc_Stub.h

  Copyright (C)2009-2012 Nintendo Co., Ltd.  All rights reserved.

  These coded instructions, statements, and computer programs contain
  proprietary information of Nintendo of America Inc. and/or Nintendo
  Company Ltd., and are protected by Federal copyright law.  They may
  not be disclosed to third parties or copied or duplicated in any form,
  in whole or in part, without the prior written consent of Nintendo.

  $Rev: 47347 $
 *---------------------------------------------------------------------------*/

//
// Do not edit this file.
// This file is automatically generated.
//

#ifndef NN_SVC_SVC_STUB_H_
#define NN_SVC_SVC_STUB_H_

#include <nn/types.h>
#include <nn/Handle.h>
#include <nn/Result.h>
#include <nn/os/os_SvcTypes.autogen.h>
#include <nn/os/os_Types.h>
#include <nn/dbg/dbg_SmallSet.h>



#ifdef __cplusplus

namespace nn {
namespace svc {

nn::Result                     ControlMemory                 ( uptr* pOut, uptr addr, uptr addr2, size_t size, bit32 operation, bit32 permission );
nn::Result                     QueryMemory                   ( nn::os::MemoryInfo* pBlockInfo, nn::os::PageInfo* pPageInfo, uptr addr );
void                           ExitProcess                   ();
nn::Result                     GetProcessAffinityMask        ( bit8 pAffinityMask[], nn::Handle process, s32 numProcessor );
nn::Result                     SetProcessAffinityMask        ( nn::Handle process, const bit8 pAffinityMask[], s32 numProcessor );
nn::Result                     GetProcessIdealProcessor      ( s32* pOut, nn::Handle process );
nn::Result                     SetProcessIdealProcessor      ( nn::Handle process, s32 processorNumber );
nn::Result                     CreateThread                  ( nn::Handle* pOut, nn::os::ThreadFunc f, uptr param, uptr stackBottom, s32 prio, s32 cpuNo );
void                           ExitThread                    ();
void                           SleepThread                   ( s64 ns );
nn::Result                     GetThreadPriority             ( s32* pOut, nn::Handle thread );
nn::Result                     SetThreadPriority             ( nn::Handle thread, s32 prio );
nn::Result                     GetThreadAffinityMask         ( bit8 pAffinityMask[], nn::Handle thread, s32 numProcessor );
nn::Result                     SetThreadAffinityMask         ( nn::Handle thread, const bit8 pAffinityMask[], s32 numProcessor );
nn::Result                     GetThreadIdealProcessor       ( s32* pOut, nn::Handle thread );
nn::Result                     SetThreadIdealProcessor       ( nn::Handle thread, s32 processorNumber );
s32                            GetCurrentProcessorNumber     ();
nn::Result                     Run                           ( nn::Handle runner, const nn::os::StartupInfo& info );
nn::Result                     CreateMutex                   ( nn::Handle* pOut, bool initialLocked );
nn::Result                     ReleaseMutex                  ( nn::Handle mutex );
nn::Result                     CreateSemaphore               ( nn::Handle* pOut, s32 initialCount, s32 maxCount );
nn::Result                     ReleaseSemaphore              ( s32* pOut, nn::Handle semaphore, s32 releaseCount );
nn::Result                     CreateEvent                   ( nn::Handle* pOut, nn::os::ResetType resetType );
nn::Result                     SignalEvent                   ( nn::Handle event );
nn::Result                     ClearEvent                    ( nn::Handle event );
nn::Result                     CreateTimer                   ( nn::Handle* pOut, nn::os::ResetType resetType );
nn::Result                     SetTimer                      ( nn::Handle timer, s64 initial, s64 interval );
nn::Result                     CancelTimer                   ( nn::Handle timer );
nn::Result                     ClearTimer                    ( nn::Handle timer );
nn::Result                     CreateMemoryBlock             ( nn::Handle* pOut, uptr pMemory, size_t size, bit32 myPermission, bit32 otherPermission );
nn::Result                     MapMemoryBlock                ( nn::Handle memBlock, uptr addr, bit32 myPermission, bit32 otherPermission );
nn::Result                     UnmapMemoryBlock              ( nn::Handle memBlock, uptr addr );
nn::Result                     CreateAddressArbiter          ( nn::Handle* arbiter );
nn::Result                     ArbitrateAddress              ( nn::Handle arbiter, uptr addr, nn::os::ArbitrationType type, s32 value, s64 ns );
nn::Result                     CloseHandle                   ( nn::Handle handle );
nn::Result                     WaitSynchronization1          ( nn::Handle handle, s64 ns );
nn::Result                     WaitSynchronizationN          ( s32* pOut, const nn::Handle handles[], s32 numHandles, bool waitAll, s64 ns );
nn::Result                     SignalAndWait                 ( s32* pOut, nn::Handle toBeSignal, const nn::Handle handles[], s32 numHandles, bool waitAll, s64 ns );
nn::Result                     DuplicateHandle               ( nn::Handle* pOut, nn::Handle original );
s64                            GetSystemTick                 ();
nn::Result                     GetHandleInfo                 ( s64* pOut, nn::Handle handle, nn::os::HandleInfoType type );
nn::Result                     GetSystemInfo                 ( s64* pOut, nn::os::SystemInfoType type, s32 param );
nn::Result                     GetProcessInfo                ( s64* pOut, nn::Handle process, nn::os::ProcessInfoType type );
nn::Result                     GetThreadInfo                 ( s64* pOut, nn::Handle thread, nn::os::ThreadInfoType type );
nn::Result                     ConnectToPort                 ( nn::Handle* pOut, const char8 name[] );
nn::Result                     SendSyncRequest1              ( nn::Handle session );
nn::Result                     SendSyncRequest2              ( nn::Handle session );
nn::Result                     SendSyncRequest3              ( nn::Handle session );
nn::Result                     SendSyncRequest4              ( nn::Handle session );
nn::Result                     SendSyncRequest               ( nn::Handle session );
nn::Result                     OpenProcess                   ( nn::Handle* pOut, bit32 processId );
nn::Result                     OpenThread                    ( nn::Handle* pOut, nn::Handle process, bit32 threadId );
nn::Result                     GetProcessId                  ( bit32* pOut, nn::Handle process );
nn::Result                     GetProcessIdOfThread          ( bit32* pOut, nn::Handle thread );
nn::Result                     GetThreadId                   ( bit32* pOut, nn::Handle thread );
nn::Result                     GetResourceLimit              ( nn::Handle* pOut, nn::Handle process );
nn::Result                     GetResourceLimitLimitValues   ( s64 values[], nn::Handle resourceLimit, const nn::os::LimitableResource names[], s32 numNames );
nn::Result                     GetResourceLimitCurrentValues ( s64 values[], nn::Handle resourceLimit, const nn::os::LimitableResource names[], s32 umNames );
nn::Result                     GetThreadContext              ( nn::os::ThreadContext* pContext, nn::Handle thread );
nn::Result                     CreatePort                    ( nn::Handle* pOutServer, nn::Handle* pOutClient, const char8 name[], s32 maxSessions );
nn::Result                     CreateSessionToPort           ( nn::Handle* pOut, nn::Handle port );
nn::Result                     CreateSession                 ( nn::Handle* pServerSession, nn::Handle* pClientSession );
nn::Result                     AcceptSession                 ( nn::Handle* pOut, nn::Handle port );
nn::Result                     ReplyAndReceive1              ( s32* pIndex, const nn::Handle pHandles[], s32 numHandle, nn::Handle replyTarget );
nn::Result                     ReplyAndReceive2              ( s32* pIndex, const nn::Handle pHandles[], s32 numHandle, nn::Handle replyTarget );
nn::Result                     ReplyAndReceive3              ( s32* pIndex, const nn::Handle pHandles[], s32 numHandle, nn::Handle replyTarget );
nn::Result                     ReplyAndReceive4              ( s32* pIndex, const nn::Handle pHandles[], s32 numHandle, nn::Handle replyTarget );
nn::Result                     ReplyAndReceive               ( s32* pIndex, const nn::Handle pHandles[], s32 numHandle, nn::Handle replyTarget );

} // end of namespace svc
} // end of namespace nn

#endif  // ifdef __cplusplus




#endif  // ifndef NN_SVC_SVC_STUB_H_
