/*---------------------------------------------------------------------------*
  Project:  Horizon
  File:     socket_User.h

  Copyright (C)2009-2012 Nintendo Co., Ltd.  All rights reserved.

  These coded instructions, statements, and computer programs contain
  proprietary information of Nintendo of America Inc. and/or Nintendo
  Company Ltd., and are protected by Federal copyright law.  They may
  not be disclosed to third parties or copied or duplicated in any form,
  in whole or in part, without the prior written consent of Nintendo.

  $Rev: 46347 $
 *---------------------------------------------------------------------------*/

//
// Do not edit this file.
// This file is automatically generated.
//

#ifndef NN_SOCKET___SOCKET_USER_H_
#define NN_SOCKET___SOCKET_USER_H_

#include <nn/Handle.h>
#include <nn/Result.h>
#include <nn/types.h>
#include <nn/socket/socket_Types.h>



namespace nn {
namespace socket {
namespace detail {

    class User
    {
    public:
        enum Tag
        {
            TAG_IPC_ERROR,
            TAG_ATTACH_PROCESS                                   = 0x0001,
            TAG_SOCKET                                           = 0x0002,
            TAG_LISTEN                                           = 0x0003,
            TAG_ACCEPT                                           = 0x0004,
            TAG_BIND                                             = 0x0005,
            TAG_CONNECT                                          = 0x0006,
            TAG_RECV_FROM                                        = 0x0007,
            TAG_RECV_FROM_SMALL                                  = 0x0008,
            TAG_SEND_TO                                          = 0x0009,
            TAG_SEND_TO_SMALL                                    = 0x000a,
            TAG_CLOSE                                            = 0x000b,
            TAG_SHUTDOWN                                         = 0x000c,
            TAG_GET_HOST_BY_NAME                                 = 0x000d,
            TAG_GET_HOST_BY_ADDR                                 = 0x000e,
            TAG_GET_ADDR_INFO                                    = 0x000f,
            TAG_GET_NAME_INFO                                    = 0x0010,
            TAG_GET_SOCK_OPT                                     = 0x0011,
            TAG_SET_SOCK_OPT                                     = 0x0012,
            TAG_FCNTL                                            = 0x0013,
            TAG_POLL                                             = 0x0014,
            TAG_SOCK_AT_MARK                                     = 0x0015,
            TAG_GET_HOST_ID                                      = 0x0016,
            TAG_GET_SOCK_NAME                                    = 0x0017,
            TAG_GET_PEER_NAME                                    = 0x0018,
            TAG_DETACH_PROCESS                                   = 0x0019,
            TAG_GET_NETWORK_OPT                                  = 0x001a,
            TAG_ICMP_SOCKET                                      = 0x001b,
            TAG_ICMP_PING                                        = 0x001c,
            TAG_ICMP_CANCEL                                      = 0x001d,
            TAG_ICMP_CLOSE                                       = 0x001e,
            TAG_GET_RESOLVER_INFO                                = 0x001f,
            TAG_SEND_TO_SMALL_MULTI                              = 0x0020,
            TAG_CLOSE_SOCKETS                                    = 0x0021,
            TAG_SET_MAX_DESCRIPTOR                               = 0x0022,
            TAG_ALLOW_OTHER_PROCESS                              = 0x0023,
            TAG_IPC_END
        };

    private:
        Handle m_Session;

    public:
        User(Handle session) : m_Session(session) {}

    public:
        nn::Result AttachProcess( nn::Handle hSharedMemory, size_t size );
        nn::Result Socket( s32* rval, s32 af, s32 type, s32 protocol );
        nn::Result Listen( s32* rval, s32 s, s32 backlog );
        nn::Result Accept( s32* rval, s32 s, u8 sockAddr[], size_t salen );
        nn::Result Bind( s32* rval, s32 s, const u8 sockAddr[], size_t salen );
        nn::Result Connect( s32* rval, s32 s, const u8 sockAddr[], size_t salen );
        nn::Result RecvFrom( s32* rval, s32 s, u8 buf[], s32 len, s32 flags, u8 sockFrom[], size_t salen );
        nn::Result RecvFromSmall( s32* rval, s32 s, u8 buf[], s32* len, s32 flags, u8 sockFrom[], size_t salen );
        nn::Result SendTo( s32* rval, s32 s, const u8 buf[], s32 len, s32 flags, const u8 sockTo[], size_t salen );
        nn::Result SendToSmall( s32* rval, s32 s, const u8 buf[], s32 len, s32 flags, const u8 sockTo[], size_t salen );
        nn::Result Close( s32* rval, s32 s );
        nn::Result Shutdown( s32* rval, s32 s, s32 how );
        nn::Result GetHostByName( s32* rval, const char8 hname[], size_t hnameLen, u8 hostCarrier[], size_t hostCarrierLen );
        nn::Result GetHostByAddr( s32* rval, const u8 addr[], size_t addrLen, s32 type, u8 hostCarrier[], size_t hostCarrierLen );
        nn::Result GetAddrInfo( s32* rval, const char8 nodeName[], size_t nodeNameLen, const char8 servName[], size_t servNameLen, const u8 hints[], s32 hintsLen, s32* resAddrNum, u8 ress[], size_t ressLen );
        nn::Result GetNameInfo( s32* rval, const u8 sa[], size_t saLen, char8 node[], size_t nodeLen, char8 service[], size_t serviceLen, s32 flag );
        nn::Result GetSockOpt( s32* rval, s32 s, s32 level, s32 optname, u8 optval[], s32* optlen );
        nn::Result SetSockOpt( s32* rval, s32 s, s32 level, s32 optname, const u8 optval[], s32 optlen );
        nn::Result Fcntl( s32* rval, s32 s, s32 cmd, s32 val );
        nn::Result Poll( s32* rval, const nn::socket::PollFd fds_in[], nn::socket::PollFd fds_out[], u32 nfds, s32 timeout );
        nn::Result SockAtMark( s32* rval, s32 s );
        nn::Result GetHostId( u32* hostId );
        nn::Result GetSockName( s32* rval, s32 s, u8 sockAddr[], size_t salen );
        nn::Result GetPeerName( s32* rval, s32 s, u8 sockAddr[], size_t salen );
        nn::Result DetachProcess();
        nn::Result GetNetworkOpt( s32* rval, s32 level, s32 optname, u8 optval[], s32* optlen );
        nn::Result IcmpSocket( s32* rval, s32 af );
        nn::Result IcmpPing( s32* rval, s32 s, const u8 data[], s32 len, const u8 remote[], size_t salen, s32 timeout );
        nn::Result IcmpCancel( s32* rval, s32 s );
        nn::Result IcmpClose( s32* rval, s32 s );
        nn::Result GetResolverInfo( s32* rval, u8 pDnsServerInfo[], size_t len );
        nn::Result SendToSmallMulti( s32* rval, s32 s, const u8 bufForMulti[], s32 len, s32 flags, const u8 sockToArray[], size_t salen, size_t satotallen );
        nn::Result CloseSockets();
        nn::Result SetMaxDescriptor( s32 number );
        nn::Result AllowOtherProcess( s32 s );
    };

} // end of namespace detail
} // end of namespace socket
} // end of namespace nn



#endif  // ifndef NN_SOCKET___SOCKET_USER_H_
